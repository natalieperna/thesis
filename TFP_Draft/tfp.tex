\documentclass{Styles/llncs}

\usepackage{amsmath}

\usepackage{Styles/agda}

\usepackage{listings}

% Listings Settings
\lstdefinestyle{blockhaskell}{
  language=Haskell,
  basicstyle=\linespread{1}\normalsize\ttfamily,
  showspaces=false,
  showstringspaces=false,
  tabsize=2,
  breaklines=true
}
\lstdefinestyle{inline}{
  basicstyle=\ttfamily\normalsize
}
\lstset{style=inline}

\title{(Re-)Creating Sharing in the GHC Backend for Agda}
\author{Natalie Perna\inst{1} \and Dr. Wolfram Kahl\inst{1}}
\institute{Department of Computing and Software, McMaster University, Hamilton, Canada}
\begin{document}

\maketitle

\begin{abstract}
Lorem ipsum dolor sit amet.
\end{abstract}

\section{Introduction}

Agda \cite{norell2007} is a dependently-typed programming language and theorem prover, supporting proof construction in a functional programming style. Due to its incredibly flexible concrete syntax and support for Unicode identifiers \cite{bove2009}, Agda can be used to construct elegant and expressive proofs in a format that is understandable even to those unfamiliar with the tool. As a result, many users of Agda, including our group, are quick to sacrifice speed and efficiency in our code in favour of proof clarity. This makes a highly-optimized compiler backend a particularly essential tool for practical development with Agda.

\section{Background}

\subsection{Agda}
\label{sec:agda}

Agda is a dependently typed functional programming language.
% TODO incorporate this figure somehow:
The core syntax of Agda is a dependently typed lambda calculus, with a simple grammar as shown in Figure~\ref{fig:grammar}.

\begin{figure}
\begin{align*}
a ::=~& x               & \text{variable}\\
    |~& \lambda x \to a & \text{abstraction}\\
    |~& a~a             & \text{application}\\
    |~& (x : a) \to a   & \text{function space}\\
    |~& Set[n]          & \text{universe}\\
    |~& (a)             & \text{grouping}
\end{align*}
\caption{Agda core syntax grammar.\cite{agdawiki}}
\label{fig:grammar}
\end{figure}

\subsubsection{Module System}
% Either before or after compiler subsection
% Discuss Agda module system and its translation
% Arguments inheited from all enclosing modules
% How sharing is "lost"

\subsubsection{Compiler}
\label{sec:agda_compiler}

The Agda programming language's first and most-used backend is MAlonzo, or more generically, the GHC (Glasgow Haskell Compiler) backend.\cite{benke2007} Given an Adga module containig a \AgdaFunction{main} function, the Agda \texttt{-{}-compile} option will compile the program using the GHC backend, which translates an Agda program into Haskell source. The generated Haskell source can then be automatically or manually (with \texttt{-{}-ghc-dont-call-ghc}) compiled to an executable program via GHC.\cite{agdadocs} % http://agda.readthedocs.io/en/latest/tools/compilers.html

Though there are several stages of translation and compilation in this process, the two transitions of primary interest for our optimizations are:
\begin{enumerate}
\item the conversion of compiled clauses to a ``treeless'' syntax, and
\item the conversion of treeless to Haskell source.
\end{enumerate}

The \lstinline{ToTreeless} translation occurs after Agda type-checking, and before Haskell source is generated.

Agda functions are implemented by giving both a type and a definition. Functions on datatypes can be defined by pattern matching on the constructors of that datatype, describing structurally recursive functions.\cite{agdawiki} % http://wiki.portal.chalmers.se/agda/agda.php?n=Docs.DatatypeAndFunctionDefinitions
Because function definitions in Agda are written as a series of one or more pattern matching clauses on possible variable inputs, we can construct an equivalent definition via case tree.\cite{agdawiki} % http://wiki.portal.chalmers.se/agda/agda.php?n=Docs.PatternMatching
Compiled clauses are, simply put, case trees.

This should sound familiar to users of functional programming languages like Haskell. Unlike Haskell, however, Agda does not permit partial functions. Therefore, functions defined by pattern matching must not exclude any possible cases from the pattern matching clauses.\cite{agdawiki} % http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Totality#Coveragechecking}
Once coverage checking is completed, pattern matching can be translated into case trees by successively splitting on each variable.\cite{agdahackage} % https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-TypeChecking-CompiledClause.html
% TODO Take for example the following case tree equivalence for a foo function, defined by pattern matching, in Agda: ??? \cite{https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-TypeChecking-CompiledClause.html}

%Compiled clauses are case trees with their bodies.
%Document compiled clauses: https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-TypeChecking-CompiledClause.html

The treeless syntax is the input to the compiler backend of Agda. After all type-checking is complete, the higher-level internal syntax of compiled clauses is translated to a ``treeless'' syntax, the name for which is derived from its use of case expressions instead of case trees. The other notable difference between compiled clauses and treeless syntax is the absence of datatypes and constructors.\cite{agdahackage} %TODO WHY? % https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-Syntax-Treeless.html

\paragraph{Treeless Syntax}

The treeless syntax is constructed from \lstinline{TTerm}s %TODO What does the T stand for?
and is a representation of the abstract syntax tree for the compiler backend. It can be reasoned about as a lambda calculus with all local variable using de Bruijn indices. A listing of \lstinline{TTerm} constructors is shown in Figure~\ref{code:TTerm}.

In this section we examine the constructors of \lstinline{TTerm}s one-by-one\cite{agdahackage}, then discuss how substitutions can be safely performed on \lstinline{TTerm}s as a preface for discussing our optimizations.

% TODO Read about how sharing is lost with substitution in the agda mailing list: https://lists.chalmers.se/pipermail/agda/2017/009379.html

\begin{figure}
\begin{lstlisting}[style=blockhaskell]
type Args = [TTerm]

data TTerm = TVar Nat
           | TPrim TPrim
           | TDef QName
           | TApp TTerm Args
           | TLam TTerm
           | TLit Literal
           | TCon QName
           | TLet TTerm TTerm
           | TCase Nat CaseType TTerm [TAlt]
           | TUnit
           | TSort
           | TErased
           | TError TError

data TAlt = TACon QName Nat TTerm
          | TAGuard TTerm TTerm
          | TALit Literal TTerm
\end{lstlisting}
\caption{\lstinline{TTerm} and \lstinline{TAlt} datatype definitions.}
\label{code:TTerm}
\end{figure}

% TODO present de bruijn indices

A \textbf{\lstinline{TVar}} is a de Bruijn indexed variable term.

A \textbf{\lstinline{TPrim}} is a compiler-related primitive, such as addition, subtraction and equality on some primitive types.

A \textbf{\lstinline{TDef}} is a qualified name identifying a function or datatype definition % TODO confirm

A \textbf{\lstinline{TApp}} is a \lstinline{TTerm} applied to a list of arguments, where each argument is itself a \lstinline{TTerm}.

A \textbf{\lstinline{TLam}} % TTerm

A \textbf{\lstinline{TLit}} % Literal

A \textbf{\lstinline{TCon}} % QName

A \textbf{\lstinline{TLet}} introduces a new local term binding in a term body.           

A \textbf{\lstinline{TCase}} is a case expression on a case scrutinee (always a de Bruijn indexed variable), a case type, a default value and a list of alternatives.

The case alternatives, \textbf{\lstinline{TAlt}}s, may be constructed from:
\begin{itemize}
\item a \lstinline{TACon}, which matches on a constructor of a given qualified name, binding the appropriate number of pattern variables to the body term if a match is made. Note that a \lstinline{TCase}'s list of \lstinline{Args} must have unique qualified names for each \lstinline{TACon}.
\item a \lstinline{TAGuard}, which matches on a boolean guard and binds no variables if matched against.
\item a \lstinline{TALit}, which matches on a literal term.
\end{itemize}
          
A \textbf{\lstinline{TUnit}} is used for levels. % TODO what does that mean

A \textbf{\lstinline{TSort}}

A \textbf{\lstinline{TErased}}

A \textbf{\lstinline{TError}} is used to indicate a runtime error.

\subsection{Lambda Calculus}
\label{sec:lambda_calc}

% TODO actually introduce what lambda calculus is. Musa suggests this: https://pdfs.semanticscholar.org/2d0a/07723f93b26c3d673f386ac903cdcb6cc521.pdf

In order to perform the desired optimisations on the abstract syntax tree, we must be able to perform substitutions on terms. Treating the \lstinline{TTerm} structure as a specialized $\lambda$-calculus, we can implement substitution as a function on terms.

Because our terms are built on de Bruijn indexed variables, we use the explicit substitution of a $\lambda\sigma$-calculus as a reference for understanding correct substitution on terms in the context of local variables bound by incrementing indices. The $\lambda\sigma$-calculus is a refinement of the $\lambda$-calculus where substitutions are manipulated explicitly, and substitution application is a term constructor rather than a meta-level notation.\cite{abadi1991}

\subsubsection{De Bruijn indices}

In order to eliminate the need for named variables in $\lambda$-calculus notation, de Bruijn notation is used to represent bound terms (variables) with natural numbers. In any term, the positive integer $n$ refers to the $n$th surrounding $\lambda$ binder.\cite{debruijn1972}

% TODO Graphical example like this: https://en.wikipedia.org/wiki/De_Bruijn_index#/media/File:De_Bruijn_index_illustration_1.svg, but emphasize that in different scope locations, different numbers point to the same bound variable.

Take then, for instance, a simple case of the classical application of the $\beta$-rule (See Figure~\ref{eq:beta_rule}). Beta reduction is the process of simplifying an application of a function to the resulting substituted term. However, in order to $\beta$-reduce $(\lambda a)b$, we must not only substitute $b$ into the appropriate occurrences in $a$. As the $\lambda$ binding disappears, we must also decrement all remaining free indices in $a$. This adapted form of the $\beta$-rule can be represented by the infinite substitution showin in Figure~\ref{eq:beta_rule2}).\cite{abadi1991}

% TODO Combine beta rule figures into subfigures a and b in a single figure

\begin{figure}
\begin{equation*}
(\lambda x.t)s \to_{\beta} t[x := s]
\end{equation*}
\caption{The classical $\beta$-reduction rule.}
\label{eq:beta_rule}
\end{figure}

\begin{figure}
\begin{equation*}
(\lambda t)s \to_{\beta} t[1 := s, 2 := 1, 3 := 2, ...]
\end{equation*}
\caption{The modified $\beta$-reduction rule for de Bruijn notation.}
\label{eq:beta_rule2}
\end{figure}

However, the substitution in this adapted rule must be evaluated carefully to produce a correct result. Consider if the term $t$ contains another $\lambda$ binding. As the substitution is applied to that nested $\lambda$ term, occurences of $1$ should not be replaced with $s$, because occurrences of $1$ refer to the nested $\lambda$ term's bound variable. Instead, occurrences of $2$ should be replaced with $s$; likewise, occurrences of $3$ should be replaced by $2$, and so on. We thus ``shift'' the substitution.\cite{abadi1991}

It is also important when applying substitutions to $\lambda$ terms that we avoid the unintended capture of free variables in our terms being substituted in. Imagine again the nested $\lambda$ term, with occurences of $2$ being replaced with $s$. Occurences of $1$ in $s$ must be replaced with $2$, else the nested $\lambda$ binder will capture the index. We this ``lift'' the indices of $s$. These two caveats result in the substitution rule in Figure~\ref{eq:debruijn_sub}.\cite{abadi1991}

\begin{figure}
\begin{equation*}
(\lambda t)[1 := s, 2 := 1, ...] = \lambda t[2 := s[1 := 2, 2 := 3, ...], 3 := 2, ...]
\end{equation*}
\caption{The substitution rule for de Bruijn indexed lambda terms.}
\label{eq:debruijn_sub}	
\end{figure}

Recognizing the required index ``shifting'' and ``lifting'' in the Figure~\ref{eq:debruijn_sub} substitution rule should suffice as background for understanding the variable manipulation performed in our optimisation.

% Here has a good introduction that may be a good reference: http://fi.ort.edu.uy/innovaportal/file/5328/3/formalisationconstructivetypetheorystoughtonsubstitution.pdf

\section{Generating Pattern Lets}

We can avoid generating certain trivial case expressions in our Haskell expressions by identifying structures like the following in our Agda terms:

\begin{lstlisting}
let v0 = e
in case v0 of
  C0 v1 v2 v3 -> t
\end{lstlisting}

and transforming them into ``pattern lets'':

\begin{lstlisting}
let v0@(C0 v1 v2 v3) = e
in t
\end{lstlisting}

Our first optimisation centres around generating these ``pattern lets''. The function \lstinline{term :: T.TTerm -> CC HS.Exp} in the Agda compiler backend transforms Agda terms into Haskell expressions. In this function, we introduced a new alternative that matches on terms with potential to be transformed into pattern lets, namely let expressions where the let body is a case expression, with a single constructor alternative, scrutinizing the variable bound by the parent let. Because these Agda terms used de Bruijn indexed variables, that means the case expression should be scrutinizing the 0 (most recently bound) variable.

\begin{lstlisting}
  TLet _ (TCase 0 _ _ [TACon _ _ _])
    | genPLet
    , Just (PLet {pletNumBinders = numBinders, eTerm = TLet t1 tp}, tb) <- splitPLet tm0
    -> do
        t1' <- term t1
        intros 1 $ \[x] -> do
          intros numBinders $ \xs -> do
            tb' <- term tb
            p <- addAsPats (x:xs) 1 tp (HS.PVar x)
            return $ hsPLet p (hsCast t1') tb'
\end{lstlisting}

\begin{lstlisting}
-- | In @addAsPats xs numBound tp pat@, recurse through @tp@ to find all
--   single constructor @TCase@s and replace @PVar@s of the same scrutinee
--   with appropriate @PAsPat@s, until @TErased@ is reached.
--   @xs@ contains all necessary variables introduce by the initial call
--   in @term@, with @numBound@ indicating the number of introduced
--   of variables introduced by the caller used in @PApp@s and the top let.
addAsPats :: [HS.Name] -> Nat -> TTerm -> HS.Pat -> CC HS.Pat
addAsPats xs numBound
  tp@(TCase sc _ _ [TACon c cArity tp'])
  pat = case xs !!! (numBound - 1 - sc) of
    Just scName -> do
      erased <- lift $ getErasedConArgs c
      hConNm <- lift $ conhqn c
      let oldPat = HS.PVar scName
      let vars = take cArity $ drop numBound xs
      let newPat = HS.PAsPat scName $ HS.PApp hConNm $ map HS.PVar [ x | (x, False) <- zip vars erased ]
      let pat' = replacePats oldPat newPat pat
      addAsPats xs (numBound + cArity) tp' pat'
    Nothing -> __IMPOSSIBLE__
addAsPats _ _ TErased pat = return pat
addAsPats _ _ _ _ = __IMPOSSIBLE__ -- Guaranteed by splitPLet

-- | In @replacePats old new p@, replace all instances of @old@ in @p@
--   with @new@
replacePats :: HS.Pat -> HS.Pat -> HS.Pat -> HS.Pat
replacePats old new p@(HS.PVar _) = if old == p then new else p
replacePats old new (HS.PAsPat sc p) = HS.PAsPat sc $ replacePats old new p
replacePats old new p@(HS.PApp q pats) =
  HS.PApp q $ map (replacePats old new) pats
replacePats _ _ p = __IMPOSSIBLE__ -- Guaranteed by addAsPats
\end{lstlisting}

\bibliographystyle{Styles/splncs}

\bibliography{ref}

\end{document}
