\chapter{Application of Main}
\label{cha:application_of_main}

In this chapter, we look at the effect of the optimisation techniques formulated in Chapter~\ref{cha:main_chapter} on different Agda code samples. Through a series of examples, we will see the effect of these optimisations and the degree to which they can yield increases in efficiency for both memory allocation space and execution time.

\edcomm{NP}{Show negligible impact on compile time}

\section{Simple Module}

\input{Figures/Agda/latex/Example1}

Take for example the simple usage of record projections in Figure~\ref{code:example1_agda}. When we compile this module once without \texttt{-{}-inline-proj} on, and once again with \texttt{-{}-inline-proj} enabled, a unified diff of the two generated Haskell files gives us what is shown in Figure~\ref{fig:Example1_inline}.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Figures/Example1_inline}
    \caption{Unified difference of the \AgdaModule{Example1}~module compiled without and then with \texttt{-{}-inline-proj}.}
    \label{fig:Example1_inline}
\end{figure}

The compiled projection function \AgdaField{Pair.snd}, that is \lstinline{d18} in the Haskell code, is replaced with a Haskell expression that cases on the pair (\AgdaFunction{p} in Agda, \lstinline{d22} in Haskell) and returns the second field.

\edcomm{NP}{Move this somewhere else}

This inline expansion can yield benfits on its own in certain codebases (see Section~TODO) by creating opportunities for GHC to optimise. The resulting inlined code also gives us better opportunities for further optimization within the Agda backend, as we discuss in Sections TODO and TODO.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.5\textwidth]{Figures/Example1_squash}
    \caption{Unified difference of the \AgdaModule{Example1}~module compiled  with \texttt{-{}-inline-proj} and then also with \texttt{-{}-squash-cases}.}
    \label{fig:Example1_squash}
\end{figure}

We then compile the same file with both \texttt{-{}-inline-proj} and \texttt{-{}-squash-cases}, and the difference between only inlining and both inlining and squashing can be seen in Figure~\ref{fig:Example1_squash}.

\section{RATH-Agda Main}
\label{sec:app_one}

RATH-Agda is a basic category and allegory theory library developed by Kahl, et al.\cite{kahl2017} It includes theories relating to semigroupoids, division allegories, typed Kleene algebras and monoidal categories, among other topics.\cite{kahl2017} The RATH-Agda repository also provides a set of test cases in a \AgdaModule{Main} module, which can be used to test a variety of typical uses of the library's functions.

\subsection{Before}

\input{Figures/Output/MainProf}

In profiling the runtime of this \AgdaModule{Main} module, we found that an inordinate amount of time was spent on evaluating simple record projections. The first few lines of the profiling report in Figure~\ref{fig:main_prof} indicate that the greatest cost centres in terms of time are the two simple record projections for the $\Sigma$ data type, with a combined 17.6\% of execution time spent evaluating them.

Because enabling profiling does have an affect on execution, we also re-compiled the module without profiling and ran it six times, measuring execution time with the Unix \texttt{time} command, to determing its average runtime as 1.60 seconds.

\subsection{After}

\input{Figures/Output/MainInlineProf}

By compiling \AgdaModule{Main} with our new option, \texttt{-{}-inline-proj}, enabled, we reduced total runtime and memory allocation, as can be seen by comparing Figure~\ref{fig:main_inline_prof} and Figure~\ref{fig:main_prof}.

We again re-compiled the module without profiling and ran it six times, measuring execution time with the Unix \texttt{time} command, to determing its average runtime with projections inlined as 1.44 seconds. We therefore produced a speedup of 1.11$\times$.

\section{Conclusion}
\label{sec:application_conclusion}

TODO

