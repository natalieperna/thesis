%# Inline expansion

%Inline expansion replaces a function call site with the body of the called function

In this chapter, we introduce the necessary compiler theory and logical background concepts required for the understanding of the material presented in the thesis. In Section~\ref{sec:section_one}, we give an introduction to the Agda compiler and the GHC backend. In Section~\ref{sec:section_two}, we give definitions and examples of EFG. Finally, in Section~\ref{sec:background_conclusion}, we conclude with a summary of the core concepts and describe where they are used throughout the remainder of the thesis.

\section{Section One}
\label{sec:section_one}
% Begin Section

\subsection{Agda}

Agda is a dependently typed functional programming language.

%The Agda package: https://hackage.haskell.org/package/Agda

% Include an Agda tutorial as per: http://dspace.library.uu.nl:8080/handle/1874/256628
% or is it necessary to understand thesis?

The core syntax of Agda is a dependently typed lambda calculus, with a simple grammar as shown in Figure~\ref{fig:grammar}.

\begin{figure}
\begin{align*}
a ::=~& x               & \text{variable}\\
    |~& \lambda x \to a & \text{abstraction}\\
    |~& a~a             & \text{application}\\
    |~& (x : a) \to a   & \text{function space}\\
    |~& Set[n]          & \text{universe}\\
    |~& (a)             & \text{grouping}
\end{align*}
\caption{Agda core syntax grammar.\cite{agdawiki}}
\label{fig:grammar}
\end{figure}

\subsection{Compiler}

The Agda programming language's first and most-used backend is MAlonzo, or more generically, the GHC (Glasgow Haskell Compiler) backend.\cite{benke2007} Given an Adga module containig a \lstinline{main} function, the Agda \texttt{--compile} option will compile the program using the GHC backend, which translates an Agda program into Haskell source. The generated Haskell source can then be automatically or manually (with \texttt{--ghc-dont-call-ghc}) compiled to an executable program via GHC.\cite{agdadocs} % http://agda.readthedocs.io/en/latest/tools/compilers.html

Though there are several stages of translation and compilation in this process, the transition of primiary interest for our optimization is the conversion of compiled clauses to a ``treeless'' syntax, after Agda type-checking, but before Haskell source is generated.

Agda functions are implemented by giving both a type and a definition. Functions on datatypes can be defined by pattern matching on the constructors of that datatype, describing structurally recursive functions.\cite{agdawiki} % http://wiki.portal.chalmers.se/agda/agda.php?n=Docs.DatatypeAndFunctionDefinitions
Because function definitions in Agda are written as a series of one or more pattern matching clauses on possible variable inputs, we can construct an equivalent definition via case tree.\cite{agdawiki} % http://wiki.portal.chalmers.se/agda/agda.php?n=Docs.PatternMatching
Compiled clauses are, simply put, case trees.

This should sound familiar to users of functional programming languages like Haskell. Unlike Haskell, however, Agda does not permit partial functions. Therefore, functions defined by pattern matching must not exclude any possible cases from the pattern matching clauses.\cite{agdawiki} % http://wiki.portal.chalmers.se/agda/pmwiki.php?n=ReferenceManual.Totality#Coveragechecking}
Once coverage checking is completed, pattern matching can be translated into case trees by successively splitting on each variable.\cite{agdahackage} % https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-TypeChecking-CompiledClause.html
% TODO Take for example the following case tree equivalence for a foo function, defined by pattern matching, in Agda: ??? \cite{https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-TypeChecking-CompiledClause.html}

%Compiled clauses are case trees with their bodies.
%Document compiled clauses: https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-TypeChecking-CompiledClause.html

The treeless syntax is the input to the compiler backend of Agda. After all type-checking is complete, the higher-level internal syntax of compiled clauses is translated to a ``treeless'' syntax, the name for which is derived from its use of case expressions instead of case trees. The other notable difference between compiled clauses and treeless syntax is the absence of datatypes and constructors.\cite{agdahackage} %TODO WHY? % https://hackage.haskell.org/package/Agda-2.5.2/docs/Agda-Syntax-Treeless.html

\subsection{Agda Module System}
% Either before or after compiler section
% Discuss Agda module system and its translation
% Arguments inheited from all enclosing modules

\subsection{Lambda Calculus}

The treeless syntax is constructed from \lstinline{TTerm}s %TODO What does the T stand for?
where all local variable use de Bruijn indices. A listing of \lstinline{TTerm} constructors is shown in Figure~\ref{code:TTerm}.
% glorified lambda calculus with db indicies

% TTerm is the AST type for compiler backend, not internal syntax
% internal syntax is before and during type checking (in agdai)

% TODO Read about how sharing is lost with substitution in the agda mailing list: https://lists.chalmers.se/pipermail/agda/2017/009379.html

\begin{figure}
\begin{lstlisting}[style=blockhaskell]
data TTerm = TVar Nat -- Type synonym for Int
           | TPrim TPrim
           | TDef QName
           | TApp TTerm Args -- [TTerm]
           | TLam TTerm
           | TLit Literal
           | TCon QName
           | TLet TTerm TTerm
           -- ^ introduces a new local binding. The bound term
           -- MUST only be evaluated if it is used inside the body.
           -- Sharing may happen, but is optional.
           -- It is also perfectly valid to just inline the bound term in the body.
           | TCase Int CaseType TTerm [TAlt]
           -- ^ Case scrutinee (always variable), case type, default value, alternatives
           -- First, all TACon alternatives are tried; then all TAGuard alternatives
           -- in top to bottom order.
           -- TACon alternatives must not overlap.
           | TUnit -- used for levels right now
           | TSort
           | TErased
           | TError TError
           -- ^ A runtime error, something bad has happened.
  deriving (Typeable, Show, Eq, Ord)
\end{lstlisting}
\caption{\lstinline{TTerm} datatype definition.}
\label{code:TTerm}
\end{figure}

% substitutions aren't part of the lambda calculus syntax, that's why this isn't a lambda-sigma-calculus

% here we do substitution as a function on terms

%explicit subst is when applysubst is a term constructor (which obviously it isn't here)

% paper for understanding substitution in context of db indices

% add talt

TODO Stuff from \cite{abadi1991}
% Here has a good introduction that may be a good reference: http://fi.ort.edu.uy/innovaportal/file/5328/3/formalisationconstructivetypetheorystoughtonsubstitution.pdf

% End Section

\section{Section Two}
\label{sec:section_two}
% Begin Section

Donec scelerisque risus et sollicitudin consectetur. In ac mattis lorem. Quisque commodo odio dui, a iaculis metus tristique et. Suspendisse sit amet interdum nunc, pretium gravida metus. Suspendisse a erat egestas, egestas mi a, tincidunt mi. Vivamus justo orci, porttitor ac tincidunt sit amet, fringilla eget neque. Integer at cursus quam. Ut malesuada ullamcorper erat finibus vestibulum. Nulla ullamcorper, enim ac accumsan placerat, lorem magna consequat nulla, nec pulvinar lacus neque vel quam. Donec posuere velit in leo vestibulum bibendum. Sed scelerisque magna vel orci tempor, vel bibendum nulla consequat. Maecenas varius nec leo eget volutpat. Vivamus vulputate mollis blandit. Nulla ligula risus, tincidunt nec dolor ac, ornare ultricies risus~\cite{Schmidt1993aa}.

Mauris fermentum, nibh mollis cursus congue, orci velit imperdiet libero, ac mollis nunc nunc ut ex. Etiam tellus nibh, pellentesque et turpis ac, aliquet maximus turpis. Etiam ornare justo ac sodales rutrum. Morbi sed tellus enim. Donec malesuada ante tortor, sit amet tempus turpis molestie venenatis. Sed vitae eros vitae elit ultricies tincidunt. Nullam quis velit semper nisi ullamcorper ullamcorper eu id elit. Cras malesuada vehicula purus, et mattis turpis volutpat eu.
\input{Definitions/defCartesianProduct}

% End Section

\section{Conclusion}
\label{sec:background_conclusion}
% Begin Section

The objective of this chapter is to give readers the required mathematical background of our approach. We have presented ABC and EFG since we will be ...  will be discussed further in Chapter~\ref{cha:main_chapter}.

% End Section
