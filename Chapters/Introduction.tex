In this chapter, we introduce dependently typed functional programming. In Section~\ref{sec:general_context}, we give an introduction to the Agda programming language and explain its history, advantages, and potential future. In Section~\ref{sec:specific_context}, we introduce the Agda compiler and GHC. In Section~\ref{sec:literature_survey}, we provide a review of the literature and discuss some existing techniques for improving functional code with optimising compilers and indicating how the existing techniques are not sufficient to achieve the desired performance in our use cases. In Section~\ref{sec:motivation}, we give the motivation for the new optimisation strategies introduced here. In Section~\ref{sec:problem_statement}, we state the problem subject of our work. In Section~\ref{sec:main_contributions}, we summarize our contributions, namely the optimisation strategies and their implementation in the Agda backend. Finally, in Section~\ref{sec:structure_of_the_thesis}, we give the structure of the remainder of the thesis.

\section{General Context}
\label{sec:general_context}
% Begin Section
% In Section~\ref{sec:general_context}, we give an introduction to the Agda programming language and explain its history, advantages, and potential future.

Agda \cite{norell2007} is a dependently-typed programming language and theorem prover, supporting proof construction in a functional programming style. Due to its incredibly flexible concrete syntax and support for Unicode identifiers \cite{bove2009}, Agda can be used to construct elegant and expressive proofs in a format that is understandable even to those unfamiliar with the tool. As a result, many users of Agda, including our group, are quick to sacrifice speed and efficiency in our code in favour of proof clarity. This makes a highly-optimized compiler backend a particularly essential tool for practical development with Agda.

% End Section

\section{Specific Context}
\label{sec:specific_context}
% Begin Section
% In Section~\ref{sec:specific_context}, we introduce the Agda compiler and GHC.

% End Section

\section{Literature Survey}
\label{sec:literature_survey}
% Begin Section
% In Section~\ref{sec:literature_survey}, we provide a review of the literature and discuss some existing techniques for improving functional code with optimising compilers and indicating how the existing techniques are not sufficient to achieve the desired performance in our use cases.

\subsection{Compiler Theory}

\subsubsection*{Common subexpression elimination}

Common subexpression elimination (CSE) is a compiler optimisation that reduces execution time by avoid repeated computations of the same expression.\cite{chitil1997} This very similar to our goal with case squashing. As anyone familiar with the nature of purely functional programming languages might realize, identification of common subexpressions is much simpler in a functional language thanks to the expectation of referential transparency.\cite{chitil1997} (As a reminder, referential transparency means that an expression always produces the same result regardless of the context in which it is evaluated.)

Appel first implemented CSE in the strict functional language ML's compiler in 1992.\cite{appel1992} Chitil first explored the implementation of CSE in a lazy functional language, Haskell, with his 1997 paper.\cite{chitil1997} The difficulty with implementing CSE in a lazy language is that, although common subexpressions are easy to identify, determining which common subexpressions will yield a benefit by being eliminated is more challenging. To avoid complex data flow analysis on functional code, Chitil developed some simple syntactic conditions for judging when CSE is beneficial in Haskell code.\cite{chitil1997} We omit these from our survey, as such heuristics are unnecessary for our optimisation. We instead focus on the relevant ``compilation by transformation'' approach used when implementing CSE in GHC.

The GHC compilation process consists of translating Haskell code into a second-order $\lambda$-calculus language called Core, at which point a series of optimising transformation are performed, and the backend transforms Core code into C.\cite{chitil1997} This process is very similar to the Agda compilation process, which translates Agda code into Treeless code, applies a series of optimising transformations, and finally generates Haskell code through the backend, as discussed in Section~\ref{sec:agda_compiler}. % TODO make a diagram to show this analogous process

The syntax of the Core intermediate language of Haskell is very similar to Treeless, with expressions consisting mainly of $\lambda$ abstractions, \lstinline{let} bindings, \lstinline{case} expressions, constructors, literals and function applications, much like Agda's Treeless syntax outlined in Figure~\ref{code:TTerm}.

CSE is implemented in GHC with a single recursive traversal of the Core program. For each expression, its subexpressions are first transformed, then it is determined whether the whole transformed expression has occurred already.\cite{chitil1997} An example of this is shown in Figure~\ref{code:cse_haskell}.

% TODO Review this example, it seems weird.
\begin{figure}
Given the expression:

\lstinline{let x = 3 in let y = 2+3 in 2+3+4}

the first CSE on the subexpressions yields:

\lstinline{let x = 3 in let y = 2+x in y+4}

and then the recursive transormation produces:

\lstinline{let x = 3 in let y = 2+x in 2+x+4}

\caption{Common subexpression elimination transformation in Haskell.\cite{chitil1997}}
\label{code:cse_haskell}
\end{figure}

% End Section

\section{Motivation}
\label{sec:motivation}
% Begin Section
% In Section~\ref{sec:motivation}, we give the motivation for the new optimisation strategies introduced here.

The RATH-Agda library is a category and allegory theory project developed by Kahl et al. which takes advantage of features of the Agda programming language's flexibility. In order to achieve its primary goal of natural mathematical clarity and style, it faces, like many Agda programs, performance concerns. \cite{kahl2017}

\begin{table}[h]
\centering
\caption{Profiler Results}
\label{table:profiling}
\begin{tabular}{ll}
\textbf{COST CENTRE}                                     & \textbf{\%time} \\
Data.Product.\textSigma.proj₂                                     & 13.1            \\
Data.Product.\textSigma.proj₁                                     & 7.5             \\
Data.SUList.ListSetMap...                                & 3.0
\end{tabular}
\end{table}

Using the GHC built-in profiling system, we generated profiling data for the RATH-Agda library's execution and found that the time required to evaluate simple record projections combined to be the greatest cost-centres in the data (see Table \ref{table:profiling}).

% End Section

\section{Problem Statement}
\label{sec:problem_statement}
% Begin Section
% In Section~\ref{sec:problem_statement}, we state the problem subject of our work.
% TODO Get the less RATH-focused problem statement from the poster competition poster.


% End Section

\section{Main Contributions}
\label{sec:main_contributions}
% Begin Section
% In Section~\ref{sec:main_contributions}, we summarize our contributions, namely the optimisation strategies and their implementation in the Agda backend.

The main contributions to the Agda compiler include:
\begin{enumerate}[(i)]
	\item automatic inlining of proper projections
	\item removal of duplicate case expressions
	\item TODO a debugging feature for analyzing Agda's generated code
\end{enumerate}

The Agda compiler's type checker allows us to identify proper projections, and we have developed a patch for automatically inlining such projections.

However, the pass commonly results in deeply nested case expressions, many of which are pattern matching on the same constructors as its ancestors, thereby duplicating variables that the compiler has already bound. By gathering the matched patterns throughout a pass over the nested terms, we are able to prune patterns that are unnecessarily repeated, and substitute in place the previously bound pattern variables.

% End Section

\section{Structure of the Thesis}
\label{sec:structure_of_the_thesis}
% Begin Section
% Finally, in Section~\ref{sec:structure_of_the_thesis}, we give the structure of the remainder of the thesis.

The remainder of this thesis is organized as follows:

\paragraph{Chapter~\ref{cha:background}} introduces the required compiler theory and logical background.

% TODO Maybe add a chapter for using the background to descibe contributions in less technical terms, if this doesn't get accomplished elsewhere

\paragraph{Chapter~\ref{cha:main_chapter}} describes the process by which we formulate a new technique to optimise Agda programs.

\paragraph{Chapter~\ref{cha:application_of_main}} gives a number of illustrative examples demonstrating the application of the implemented optimisation.

% TODO Maybe merge discussion and conclusion

\paragraph{Chapter~\ref{cha:discussion}} discusses the impact of our contribution in helping to remedy the problems of poor performance.

\paragraph{Chapter~\ref{cha:conclusion_and_future_work}} draws conclusions and suggests future work.

% End Section
