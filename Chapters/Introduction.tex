In this chapter, we introduce dependently typed functional programming. In Section~\ref{sec:general_context}, we give an introduction to the Agda programming language and explain its history, advantages, and potential future. In Section~\ref{sec:specific_context}, we introduce the Agda compiler and GHC. In Section~\ref{sec:literature_survey}, we provide a review of the literature and discuss some existing techniques for improving functional code with optimising compilers and indicating how the existing techniques are not sufficient to achieve the desired performance in our use cases. In Section~\ref{sec:motivation}, we give the motivation for the new optimisation strategies introduced here. In Section~\ref{sec:problem_statement}, we state the problem subject of our work. In Section~\ref{sec:main_contributions}, we summarize our contributions, namely the optimisation strategies and their implementation in the Agda backend. Finally, in Section~\ref{sec:structure_of_the_thesis}, we give the structure of the remainder of the thesis.

\section{General Context}
\label{sec:general_context}
% Begin Section
% In Section~\ref{sec:general_context}, we give an introduction to the Agda programming language and explain its history, advantages, and potential future.

Agda \cite{norell2007} is a dependently-typed programming language and theorem prover, supporting proof construction in a functional programming style. Due to its incredibly flexible concrete syntax and support for Unicode identifiers \cite{bove2009}, Agda can be used to construct elegant and expressive proofs in a format that is understandable even to those unfamiliar with the tool. As a result, many users of Agda, including our group, are quick to sacrifice speed and efficiency in our code in favour of proof clarity. This makes a highly-optimized compiler backend a particularly essential tool for practical development with Agda.\newline

% End Section

\section{Specific Context}
\label{sec:specific_context}
% Begin Section
% In Section~\ref{sec:specific_context}, we introduce the Agda compiler and GHC.

% End Section

\section{Literature Survey}
\label{sec:literature_survey}
% Begin Section
% In Section~\ref{sec:literature_survey}, we provide a review of the literature and discuss some existing techniques for improving functional code with optimising compilers and indicating how the existing techniques are not sufficient to achieve the desired performance in our use cases.

% End Section

\section{Motivation}
\label{sec:motivation}
% Begin Section
% In Section~\ref{sec:motivation}, we give the motivation for the new optimisation strategies introduced here.

The RATH-Agda library is a category and allegory theory project developed by Kahl et al. which takes advantage of features of the Agda programming language's flexibility. In order to achieve its primary goal of natural mathematical clarity and style, it faces, like many Agda programs, performance concerns. \cite{kahl2017}\newline

\begin{table}[h]
\centering
\caption{Profiler Results}
\label{table:profiling}
\begin{tabular}{ll}
\textbf{COST CENTRE}                                     & \textbf{\%time} \\
Data.Product.\textSigma.proj₂                                     & 13.1            \\
Data.Product.\textSigma.proj₁                                     & 7.5             \\
Data.SUList.ListSetMap...                                & 3.0
\end{tabular}
\end{table}

Using the GHC built-in profiling system, we generated profiling data for the RATH-Agda library's execution and found that the time required to evaluate simple record projections combined to be the greatest cost-centres in the data (see Table \ref{table:profiling}).\newline

% End Section

\section{Problem Statement}
\label{sec:problem_statement}
% Begin Section
% In Section~\ref{sec:problem_statement}, we state the problem subject of our work.
% TODO Get the less RATH-focused problem statement from the poster competition poster.


% End Section

\section{Main Contributions}
\label{sec:main_contributions}
% Begin Section
% In Section~\ref{sec:main_contributions}, we summarize our contributions, namely the optimisation strategies and their implementation in the Agda backend.

The main contributions to the Agda compiler include:
\begin{enumerate}[(i)]
	\item automatic inlining of proper projections
	\item removal of duplicate case expressions
	\item TODO a debugging feature for analyzing Agda's generated code
\end{enumerate}

The Agda compiler's type checker allows us to identify proper projections, and we have developed a patch for automatically inlining such projections.\newline

However, the pass commonly results in deeply nested case expressions, many of which are pattern matching on the same constructors as its ancestors, thereby duplicating variables that the compiler has already bound. By gathering the matched patterns throughout a pass over the nested terms, we are able to prune patterns that are unnecessarily repeated, and substitute in place the previously bound pattern variables.\newline

% End Section

\section{Structure of the Thesis}
\label{sec:structure_of_the_thesis}
% Begin Section
% Finally, in Section~\ref{sec:structure_of_the_thesis}, we give the structure of the remainder of the thesis.

The remainder of this thesis is organized as follows:

\paragraph{Chapter~\ref{cha:background}} introduces the required compiler theory and logical background.

% TODO Maybe add a chapter for using the background to descibe contributions in less technical terms, if this doesn't get accomplished elsewhere

\paragraph{Chapter~\ref{cha:main_chapter}} describes the process by which we formulate a new technique to optimise Agda programs.

\paragraph{Chapter~\ref{cha:application_of_main}} gives a number of illustrative examples demonstrating the application of the implemented optimisation.

% TODO Maybe merge discussion and conclusion

\paragraph{Chapter~\ref{cha:discussion}} discusses the impact of our contribution in helping to remedy the problems of poor performance.

\paragraph{Chapter~\ref{cha:conclusion_and_future_work}} draws conclusions and suggests future work.

% End Section
