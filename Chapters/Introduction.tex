\chapter{Introduction}
\label{cha:introduction}

In this chapter, we introduce Agda, discuss the optimisation of functional languages, and give an overview of this project. In Section~\ref{sec:general_context}, we give an introduction to the Agda programming language and explain its history, advantages, and potential future. In Section~\ref{sec:specific_context}, we introduce the Agda compiler and GHC. In Section~\ref{sec:motivation}, we give the motivation for the new optimisation strategies introduced here. In Section~\ref{sec:problem_statement}, we state the problem subject of our work. In Section~\ref{sec:main_contributions}, we summarize our contributions, namely the optimisation strategies and their implementation in the Agda backend. Finally, in Section~\ref{sec:structure_of_the_thesis}, we give the structure of the remainder of the thesis.

\section{General Context}
\label{sec:general_context}

Agda \cite{norell2007} is a dependently-typed programming language and theorem prover, supporting proof construction in a functional programming style. Due to its incredibly flexible concrete syntax and support for Unicode identifiers \cite{bove2009}, Agda can be used to construct elegant and expressive proofs in a format that is understandable even to those unfamiliar with the tool. As a result, many users of Agda, including our group, are quick to sacrifice speed and efficiency in our code in favour of proof clarity. This makes a highly-optimized compiler backend a particularly essential tool for practical development with Agda.

Agda is a dependently typed functional programming language. In traditional functional languages, types may depend on other types. For example, the Haskell type signature \lstinline{xs :: Vector a} denotes a vector containing elements of type \lstinline{a}, where \lstinline{a} is a type variable. In a dependently typed language like Agda types can depend not only on other types, but also on values. Consider the \AgdaFunction{replicate} function in Figure~\ref{code:replicate}, which produces a \AgdaDatatype{Vec}tor of elements of type \AgdaBound{A} with length \AgdaBound{n}.\cite{norell2009}

\input{Figures/Agda/latex/Replicate}

The ability for types to contain arbitrary values is significant because it allows us to encode (almost) any proposition or formula as a type. By the Curry–Howard isomorphism (or the proofs-as-programs interpretation), we can then prove these propositions true by providing an element (program) of its corresponding type.\cite{poernomo2005} In order to ensure this logic holds true for all Agda programs, the Agda type-checker requires that all programs be both total and terminating.\cite{norell2009}

Agda also supports a flexible mixfix syntax, as seen in Figure~\ref{code:if_function}, and Unicode characters, such as the \AgdaDatatype{ℕ} to represent natural numbers in Figure~\ref{code:replicate}. These features along with Agda's constructive functional style make Agda both an interesting programming language, but also a powerful proof assistant for generating elegant, expressive proofs.

\input{Figures/Agda/latex/If}

\edcomm{NP}{some kind of figure that shows a math-y proposition, its representation as a type in Agda, the corresponding program satisfying the type, thereby proving the math-y prop true}

\edcomm{NP}{Include an Agda tutorial as per: \url{http://dspace.library.uu.nl:8080/handle/1874/256628}}

\edcomm{NP}{incorporate this figure somehow:}
The core syntax of Agda is a dependently typed lambda calculus, with a simple grammar as shown in Figure~\ref{fig:grammar}.

\begin{figure}
\begin{align*}
a ::=~& x               & \text{variable}\\
    |~& \lambda x \to a & \text{abstraction}\\
    |~& a~a             & \text{application}\\
    |~& (x : a) \to a   & \text{function space}\\
    |~& Set[n]          & \text{universe}\\
    |~& (a)             & \text{grouping}
\end{align*}
\caption{Agda core syntax grammar.\cite{agdawiki}}
\label{fig:grammar}
\end{figure}

\section{Specific Context}
\label{sec:specific_context}

Agda has a number of available compilers and backends, but the one that is most efficient and most commonly used is MAlonzo, the GHC (Glasgow Haskell Compiler) backend.\cite{benke2007} The MAlonzo backend has the goal of compiling Agda code with the performance of the generated code matching that of GHC, and it does so by translating Agda into Haskell, so that it can be compiled, and optimised by GHC. This is a practical and useful arrangement for real-world Agda usage because GHC has benefited from a massive development effort by a large community to create a highly performant compiler.\cite{benke2007}

The differentiating feature that Agda provides over Haskell is a more expressive type system (see Section~\ref{sec:agda}). Because Agda supports dependent types and Haskell does not, in order for Agda generated code to pass the Haskell type checker, it is necessary for the MAlonzo backend to wrap coercions around all function arguments and all function calls, which cast terms from one type to a different arbitrary type. Unfortunately, these potentially unsafe type coercions mean that there are many GHC optimisations which Agda's generated code is ``missing out on''.\cite{fredriksson2011}

Some of the Agda optimisations described herein would typically be performed by GHC after translation to Haskell were it not for these coercions, so we instead ensure that we can still take advantage of these optimisations by implementing them in the Agda backend, before the translation to Haskell occurs.

\section{Motivation}
\label{sec:motivation}

\edcomm{NP}{Make this less RATH-focused}

The RATH-Agda library is a category and allegory theory project developed by Kahl et al. which takes advantage of features of the Agda programming language's flexibility. In order to achieve its primary goal of natural mathematical clarity and style, it faces, like many Agda programs, performance concerns. \cite{kahl2017}

\begin{table}[h]
\centering
\caption{Profiler Results}
\label{table:profiling}
\begin{tabular}{ll}
\textbf{COST CENTRE}                                     & \textbf{\%time} \\
Data.Product.\textSigma.proj₂                                     & 13.1            \\
Data.Product.\textSigma.proj₁                                     & 7.5             \\
Data.SUList.ListSetMap...                                & 3.0
\end{tabular}
\end{table}

Using the GHC built-in profiling system, we generated profiling data for the RATH-Agda library's execution and found that the time required to evaluate simple record projections combined to be the greatest cost-centres in the data. This representative usage of the RATH-Agda library spends more than 20\% of execution time on just two types of projections (see Table~\ref{table:profiling}).

\section{Problem Statement}
\label{sec:problem_statement}

For practical development in Agda a highly effective optimizing compiler backend is a particularly essential tool to avoid performance concerns.

Our work aims to introduce a number of optimising transformations to the Agda internals and backend so that Agda users can continue to focus on elegant syntax and mathematical clarity, and leave the optimisations necessary to transform that code into a program that runs with acceptable heap allocation and execution time to the compiler.

The optimisations we focus on are specifically oriented towards aiding our team's most common, and most costly, uses of the Agda programming language, but they should be useful in a general context for most Agda users.

\section{Main Contributions}
\label{sec:main_contributions}

The main contributions to the Agda compiler include:
\begin{enumerate}[(i)]
	\item automatic inlining of proper projections
	\item removal of duplicate case expressions
	\item TODO
\end{enumerate}

The Agda compiler's type checker allows us to identify proper projections, and we have developed a patch for automatically inlining such projections.

However, the pass commonly results in deeply nested case expressions, many of which are pattern matching on the same constructors as its ancestors, thereby duplicating variables that the compiler has already bound. By gathering the matched patterns throughout a pass over the nested terms, we are able to prune patterns that are unnecessarily repeated, and substitute in place the previously bound pattern variables.

\section{Structure of the Thesis}
\label{sec:structure_of_the_thesis}

The remainder of this thesis is organized as follows:

\paragraph{Chapter~\ref{cha:background}} introduces the required compiler theory and logical background.

\edcomm{NP}{Maybe add a chapter for using the background to descibe contributions in less technical terms, if this doesn't get accomplished elsewhere}

\paragraph{Chapter~\ref{cha:main_chapter}} describes the process by which we formulate a new technique to optimise Agda programs.

\paragraph{Chapter~\ref{cha:application_of_main}} gives a number of illustrative examples demonstrating the application of the implemented optimisation.

\edcomm{NP}{Maybe merge discussion and conclusion}

\paragraph{Chapter~\ref{cha:discussion}} discusses the impact of our contribution in helping to remedy the problems of poor performance.

\paragraph{Chapter~\ref{cha:conclusion_and_future_work}} draws conclusions and suggests future work.
