In this chapter, we discuss the design and implementation of our optimisations to the Agda compiler. In Section~\ref{sec:assumptions}, we list our assumptions. In Section~\ref{sec:mathematical_representation}, we give a clear mathematical representation of the problem of XYZ. In Section~\ref{sec:the_proposed_technique}, we present our technique. 

\section{Assumptions}
\label{sec:assumptions}
% Begin Section

In formulating the problem of XYZ, we make the following assumptions: 
\begin{enumerate}[(i)]
	\item Assumption one. 
	\item Assumption two. 
	\item Assumption three. 
\end{enumerate}

% End Section

\section{Inlining Projections}
\label{sec:inlining_projections}
% Begin Section

We added the option:

\begin{verbatim}
--inline-proj                               inline proper projections
\end{verbatim}

to Agda which, when enabled, will replace every call to a function that is a proper projection with its function body. (Note that proper projections do not include projection-like functions, or record field values, i.e. projections applied to an argument.)

\input{Figures/Agda/latex/Inline1}

Take for example the simple usage of record projections in Figure~\ref{code:inline1}. When we compile this module once without \texttt{--inline-proj} on, and once again with \texttt{--inline-proj} enabled, a unified \texttt{diff} of two of the generated Haskell files gives us what is shown in Figure~\ref{fig:inline1_diff}.

\begin{figure}
\begin{verbatim}
--- Inline1-compile/MAlonzo/Code/Inline1.hs
+++ Inline1-compile-inline/MAlonzo/Code/Inline1.hs
@@ -31,4 +31,9 @@
       MAlonzo.Code.IO.du42 ()
       (coe
          MAlonzo.Code.IO.d150
-         (coe MAlonzo.Code.Data.Nat.Show.d22 (coe d18 d22)))
+         (coe MAlonzo.Code.Data.Nat.Show.d22
+            (let v0 = coe d22 in
+             case coe v0 of
+               C20 v1 v2 -> coe v2
+               _ -> MAlonzo.RTE.mazUnreachableError)))
\end{verbatim}

\caption{Unified difference of the \AgdaModule{Inline1} module compiled without and then with \texttt{--inline-proj}.}
\label{fig:inline1_diff}
\end{figure}

The compiled projection function \AgdaField{Pair.snd}, that is \lstinline{d18} in the Haskell code, is replaced with a Haskell expression that cases on the pair (\AgdaFunction{p} in Agda, \lstinline{d22} in Haskell) and returns the second field.

Although this inline expansion alone does not yield great benfits, the resulting inlined code gives us greater opportunities for further optimization, as we discuss in Sections TODO and TODO.

\subsection{Performance}

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras et nibh vel mauris pharetra viverra. Integer nisl nibh, ullamcorper eget imperdiet sed, accumsan ultrices purus. Quisque malesuada vel elit in cursus. Vestibulum rutrum turpis sed lectus vehicula, et venenatis ligula varius.  In Section~\ref{sec:survey_discussion}, we discussed vivamus auctor fermentum libero, in ullamcorper diam pulvinar non. Donec condimentum cursus iaculis. Nulla odio dolor, faucibus eget mauris a, eleifend congue erat. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nullam aliquet finibus ligula eu feugiat. Aenean feugiat nunc et arcu elementum vestibulum. \newline

Pellentesque aliquet tempor condimentum. Nulla vulputate ultricies felis, ut feugiat nisl auctor a. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas dapibus turpis ac tortor ullamcorper, in eleifend mi fringilla. Nam luctus tortor pulvinar neque molestie, quis scelerisque nisi volutpat. Integer et risus facilisis, vehicula libero nec, feugiat ante. In Figure~\ref{fig:commutative_diagram}, donec ultricies libero et mauris mollis, eu pretium neque iaculis. Sed in elit quis dui molestie dapibus vitae vel sapien. Etiam fermentum maximus accumsan. \newline

\input{Figures/CommutativeDiagram}

In imperdiet purus nec eleifend finibus. Aliquam non tempor massa. Etiam ac felis et ante varius vehicula nec eget tortor. Proin posuere quis felis non rutrum. Aenean quis felis ut ex sagittis pellentesque sit amet tempus nisl. Nam nec tellus ut lorem posuere semper non ac arcu. Nulla faucibus purus libero, in pellentesque sapien commodo tristique. Etiam consectetur lectus elit, id porttitor justo dignissim interdum. Donec ut nisl metus. Nulla sed dui lacus. Donec tristique dignissim massa sed ultricies. Maecenas iaculis arcu diam, ut dictum nisi euismod vitae. Praesent id imperdiet augue. 

% End Section

\section{The Proposed Technique}
\label{sec:the_proposed_technique}
% Begin Section

The proposed technique for the detection of the leak of confidential information via covert channels has two components: monitoring the information sent on the communication channels and finding an abstraction relation relating the confidential information to the information observed to be sent on the communication channel(s).

\subsection{Monitoring the Communication Channels}
\label{sub:monitoring_the_communication_channels}
% Begin SubSection

Lorem ipsum dolor sit amet, consectetur adipiscing elit. Cras et nibh vel mauris pharetra viverra. Integer nisl nibh, ullamcorper eget imperdiet sed, accumsan ultrices purus. Quisque malesuada vel elit in cursus. Vestibulum rutrum turpis sed lectus vehicula, et venenatis ligula varius.  In Section~\ref{sec:communication}, we discussed vivamus auctor fermentum libero, in ullamcorper diam pulvinar non. Donec condimentum cursus iaculis. Nulla odio dolor, faucibus eget mauris a, eleifend congue erat. Interdum et malesuada fames ac ante ipsum primis in faucibus. Nullam aliquet finibus ligula eu feugiat. Aenean feugiat nunc et arcu elementum vestibulum. \newline

\input{Figures/Communication}

Pellentesque aliquet tempor condimentum. Nulla vulputate ultricies felis, ut feugiat nisl auctor a. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas dapibus turpis ac tortor ullamcorper, in eleifend mi fringilla. Nam luctus tortor pulvinar neque molestie, quis scelerisque nisi volutpat. Integer et risus facilisis, vehicula libero nec, feugiat ante. Donec ultricies libero et mauris mollis, eu pretium neque iaculis. Sed in elit quis dui molestie dapibus vitae vel sapien. Etiam fermentum maximus accumsan.

% End Section

\section{Conclusion}
\label{sec:problem_formulation_conclusion}
% Begin Section

Pellentesque aliquet tempor condimentum. Nulla vulputate ultricies felis, ut feugiat nisl auctor a. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas dapibus turpis ac tortor ullamcorper, in eleifend mi fringilla. Nam luctus tortor pulvinar neque molestie, quis scelerisque nisi volutpat. Integer et risus facilisis, vehicula libero nec, feugiat ante. Donec ultricies libero et mauris mollis, eu pretium neque iaculis. Sed in elit quis dui molestie dapibus vitae vel sapien. Etiam fermentum maximus accumsan

% End Section


\section{Generating Pattern Lets}

We can avoid generating certain trivial case expressions in our Haskell expressions by identifying structures like the following in our Agda terms:

\begin{lstlisting}
let v0 = e
in case v0 of
  C0 v1 v2 v3 -> t
\end{lstlisting}

and transforming them into ``pattern lets'':

\begin{lstlisting}
let v0@(C0 v1 v2 v3) = e
in t
\end{lstlisting}

Our first optimisation centres around generating these ``pattern lets''. The function \lstinline{term :: T.TTerm -> CC HS.Exp} in the Agda compiler backend transforms Agda terms into Haskell expressions. In this function, we introduced a new alternative that matches on terms with potential to be transformed into pattern lets, namely let expressions where the let body is a case expression, with a single constructor alternative, scrutinizing the variable bound by the parent let. Because these Agda terms used de Bruijn indexed variables, that means the case expression should be scrutinizing the 0 (most recently bound) variable.

\begin{lstlisting}
  TLet _ (TCase 0 _ _ [TACon _ _ _])
    | genPLet
    , Just (PLet {pletNumBinders = numBinders, eTerm = TLet t1 tp}, tb) <- splitPLet tm0
    -> do
        t1' <- term t1
        intros 1 $ \[x] -> do
          intros numBinders $ \xs -> do
            tb' <- term tb
            p <- addAsPats (x:xs) 1 tp (HS.PVar x)
            return $ hsPLet p (hsCast t1') tb'
\end{lstlisting}

\begin{lstlisting}
-- | In @addAsPats xs numBound tp pat@, recurse through @tp@ to find all
--   single constructor @TCase@s and replace @PVar@s of the same scrutinee
--   with appropriate @PAsPat@s, until @TErased@ is reached.
--   @xs@ contains all necessary variables introduce by the initial call
--   in @term@, with @numBound@ indicating the number of introduced
--   of variables introduced by the caller used in @PApp@s and the top let.
addAsPats :: [HS.Name] -> Nat -> TTerm -> HS.Pat -> CC HS.Pat
addAsPats xs numBound
  tp@(TCase sc _ _ [TACon c cArity tp'])
  pat = case xs !!! (numBound - 1 - sc) of
    Just scName -> do
      erased <- lift $ getErasedConArgs c
      hConNm <- lift $ conhqn c
      let oldPat = HS.PVar scName
      let vars = take cArity $ drop numBound xs
      let newPat = HS.PAsPat scName $ HS.PApp hConNm $ map HS.PVar [ x | (x, False) <- zip vars erased ]
      let pat' = replacePats oldPat newPat pat
      addAsPats xs (numBound + cArity) tp' pat'
    Nothing -> __IMPOSSIBLE__
addAsPats _ _ TErased pat = return pat
addAsPats _ _ _ _ = __IMPOSSIBLE__ -- Guaranteed by splitPLet

-- | In @replacePats old new p@, replace all instances of @old@ in @p@
--   with @new@
replacePats :: HS.Pat -> HS.Pat -> HS.Pat -> HS.Pat
replacePats old new p@(HS.PVar _) = if old == p then new else p
replacePats old new (HS.PAsPat sc p) = HS.PAsPat sc $ replacePats old new p
replacePats old new p@(HS.PApp q pats) =
  HS.PApp q $ map (replacePats old new) pats
replacePats _ _ p = __IMPOSSIBLE__ -- Guaranteed by addAsPats
\end{lstlisting}