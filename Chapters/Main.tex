In this chapter, we discuss the design and implementation of our optimisations to the Agda compiler. In Section~\ref{sec:assumptions}, we list our assumptions. In Section~\ref{sec:logical_representation}, we give a logical representation of the optimisations. In Section~\ref{sec:implementation}, we present our implementation, with references to source code in the Appendix.

\section{Assumptions}
\label{sec:assumptions}
% Begin Section

In formulating the problem of XYZ, we make the following assumptions: 
\begin{enumerate}[(i)]
	\item Assumption one. 
	\item Assumption two. 
	\item Assumption three. 
\end{enumerate}

% End Section

\section{Logical Representation}
\label{sec:logical_representation}

We present in Figure~\ref{fig:treeless_grammar} a simplified logical representation of the Agda treeless syntax as a grammar. We use this simplification to discuss the optimisations at a logical level of abstraction. Note that variables are represented only by their de Bruijn index.

\begin{figure}
\begin{align*}
t ::=~& i & \text{variable}\\
|~& d & \text{definition}\\
|~& t~t^* & \text{application}\\
|~& \lambda~0 \to t & \text{lambda abstraction}\\
|~& l & \text{literal}\\
|~& \mathtt{let}~0 = t~\mathtt{in}~t & \text{let}\\
|~& \mathtt{case}~i : \tau~\mathtt{of}~a^*~\mathtt{otherwise} \to t& \text{case}\\
\\
a ::=~& d~(ar-1)..0 \to t\\
|~& l \to t\\
\\
i \in~& \mathbb{N} & \text{de Bruijn index}\\
d \in~& \{\text{function or datatype name}\}\\
l \in~& \{\text{literal}\}\\
\end{align*}
\caption{Simplified representation of the Agda treeless syntax grammar.}
\label{fig:treeless_grammar}
\end{figure}

\subsection{Inlining Projections}

The logical representation of inlining is fairly straightforward. While recursing through the treeless representation of an Agda module, for every application of a defintion to a term (that is, $d~t$, where $d$ is the name of a function or datatype, identifying a definition, and $t$ is a treeless term)... TODO

\subsection{Case Squashing}

The goal of case squashing is to eliminate case expressions where the scrutinee has already been matched on by an enclosing ancestor case expression. For example, given the following simplified treeless expression:

TODO use colours to indicate which i's refer to the same variable bindings

\begin{lstlisting}[style=math]
$\lambda~0 \to$
$\lambda~0 \to$
$\lambda~0 \to$
case $2$ of {
  $da~2~1~0 \to$
    case $0$ of {
      $db~1~0 \to$
        case $7$ of {
          $da~2~1~0 \to r$
          ...
        }
      ...
    }
  ...
}
\end{lstlisting}

we can follow the de Bruijn indices to their matching variable bindings, to see that the first and third case expressions are scrutinizing the same variable, the one bound by the outermost $\lambda$ function. Therefore, with only static analysis of the expression tree, we know that the third case expression must follow the $da~2~1~0$ branch, and we can thus safely transform our expression into the following:

\begin{lstlisting}[style=math]
$\lambda~0 \to$
$\lambda~0 \to$
$\lambda~0 \to$
case $2$ of {
  $da~2~1~0 \to$
    case $0$ of {
      $db~1~0 \to$
        $r[0 := 2, 1 := 3, 2 := 4]$
      ...
    }
  ...
}
\end{lstlisting}

We perform this ``case squashing'' by accumulating an environment of all previously scrutinized variables as we traverse the tree structure (appropriately shifting de Bruijn indices in the environment as new variables are bound), and replacing case expressions matching on the same variable as an ancestor case expressions wherever possible.

\subsection{Generating Pattern Lets}

\subsection{Let Pattern Floating}
% floating let patterns as described in Issue 1895,
% possibly including FloatingCase (which will have to end up
% producing irrefutable patterns on the function left-hand sides,
% not done yet), but definitely a separate section for cross-call-floating.
% See: Log/2017-04-26_Float-across-function-calls_notes.txt

\section{Implementation}
\label{sec:implementation}

Given the Haskell data type of Agda's treeless representation, as shown in Figure~\ref{code:TTerm}...

\subsection{Inlining Projections}

TODO This isn't really implementation so much as output

We added the option:

\begin{verbatim}
--inline-proj                               inline proper projections
\end{verbatim}

to Agda which, when enabled, will replace every call to a function that is a proper projection with its function body. (Note that proper projections do not include projection-like functions, or record field values, i.e. projections applied to an argument.)

\input{Figures/Agda/latex/Inline1}

Take for example the simple usage of record projections in Figure~\ref{code:inline1}. When we compile this module once without \texttt{--inline-proj} on, and once again with \texttt{--inline-proj} enabled, a unified \texttt{diff} of two of the generated Haskell files gives us what is shown in Figure~\ref{fig:inline1_diff}.

% TODO Possibly move this earlier as motivation for the work
% TODO Replace with nicer looking diff, maybe from SourceTree?
\begin{figure}
\begin{verbatim}
--- Inline1-compile/MAlonzo/Code/Inline1.hs
+++ Inline1-compile-inline/MAlonzo/Code/Inline1.hs
@@ -31,4 +31,9 @@
       MAlonzo.Code.IO.du42 ()
       (coe
          MAlonzo.Code.IO.d150
-         (coe MAlonzo.Code.Data.Nat.Show.d22 (coe d18 d22)))
+         (coe MAlonzo.Code.Data.Nat.Show.d22
+            (let v0 = coe d22 in
+             case coe v0 of
+               C20 v1 v2 -> coe v2
+               _ -> MAlonzo.RTE.mazUnreachableError)))
\end{verbatim}

\caption{Unified difference of the \AgdaModule{Inline1} module compiled without and then with \texttt{--inline-proj}.}
\label{fig:inline1_diff}
\end{figure}

The compiled projection function \AgdaField{Pair.snd}, that is \lstinline{d18} in the Haskell code, is replaced with a Haskell expression that cases on the pair (\AgdaFunction{p} in Agda, \lstinline{d22} in Haskell) and returns the second field.

This inline expansion can yield benfits on its own in certain codebases (see Section~TODO) by creating opportunities for GHC to optimise. The resulting inlined code also gives us better opportunities for further optimization within the Agda backend, as we discuss in Sections TODO and TODO.

\subsection{Case Squashing}

TODO

\subsection{Generating Pattern Lets}

We can avoid generating certain trivial case expressions in our Haskell expressions by identifying structures like the following in our Agda terms:

\begin{lstlisting}
let v0 = e
in case v0 of
  C0 v1 v2 v3 -> t
\end{lstlisting}

and transforming them into ``pattern lets'':

\begin{lstlisting}
let v0@(C0 v1 v2 v3) = e
in t
\end{lstlisting}

Our next optimisation centres around generating these ``pattern lets''. The function \lstinline{term :: T.TTerm -> CC HS.Exp} in the Agda compiler backend transforms Agda terms into Haskell expressions. In this function, we introduced a new alternative that matches on terms with potential to be transformed into pattern lets, namely let expressions where the let body is a case expression, with a single constructor alternative, scrutinizing the variable bound by the parent let. Because these Agda terms used de Bruijn indexed variables, that means the case expression should be scrutinizing the 0 (most recently bound) variable.

...

\subsection{Let Pattern Floating}

\section{Conclusion}
\label{sec:main_conclusion}
% Begin Section

Pellentesque aliquet tempor condimentum. Nulla vulputate ultricies felis, ut feugiat nisl auctor a. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Maecenas dapibus turpis ac tortor ullamcorper, in eleifend mi fringilla. Nam luctus tortor pulvinar neque molestie, quis scelerisque nisi volutpat. Integer et risus facilisis, vehicula libero nec, feugiat ante. Donec ultricies libero et mauris mollis, eu pretium neque iaculis. Sed in elit quis dui molestie dapibus vitae vel sapien. Etiam fermentum maximus accumsan

% End Section
