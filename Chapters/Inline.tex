\chapter{Inlining Projections}
\label{cha:inline_proj}

\section{Usage}

We added the option:

\begin{verbatim}
--inline-proj                               inline proper projections
\end{verbatim}

to our Agda branch which, when enabled, will replace every call to a function that is a proper projection with its function body.

\section{Logical Representation}

The logical representation of inlining is fairly straightforward. We recurse through the treeless representation of an Agda module. For every application of a function or datatype to a list of arguments, that is $d~t^*$, where $d$ is the name of a function or datatype, and $t$s are treeless terms, we replace $d~t^*$ with the function or datatype definition corresponding to $d$ and substitute in the $t^*$ arguments.

\section{Implementation}

It is worth noting that the only projections which we identify and inline are ``proper projections'', that is, we do not include projection-like functions, or record field values, i.e. projections applied to an argument.

The only major complication in implementing the projection inlining optimisation is accounting for the potential for recursive inlining to loop, resulting in non-termination of compilation. Therefore, when inlining projections, we maintain an environment of previously inlined projections and avoid inlining the same projection more than one level deep.

For a complete listing of our implementation of the projection inlining optimisation, refer to Appendix~\ref{app:to_treeless}. The \lstinline{Agda.Compiler.ToTreeless} module is responsible for converting Agda's internal syntax to the treeless syntax. It is during this translation that other manual forms of definition inlining are performed, so we introduce our optimisation as an additional guard on translating internal \lstinline{Def}s, which checks whether the definition is a projection, and performs inlining if it  is.
